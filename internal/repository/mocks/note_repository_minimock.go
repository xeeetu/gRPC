// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/xeeetu/gRPC/internal/repository.NoteRepository -o note_repository_minimock.go -n NoteRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/xeeetu/gRPC/model"
)

// NoteRepositoryMock implements mm_repository.NoteRepository
type NoteRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, info *model.NoteInfo) (i1 int64, err error)
	funcCreateOrigin    string
	inspectFuncCreate   func(ctx context.Context, info *model.NoteInfo)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mNoteRepositoryMockCreate

	funcDelete          func(ctx context.Context, id int64) (err error)
	funcDeleteOrigin    string
	inspectFuncDelete   func(ctx context.Context, id int64)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mNoteRepositoryMockDelete

	funcGet          func(ctx context.Context, id int64) (np1 *model.Note, err error)
	funcGetOrigin    string
	inspectFuncGet   func(ctx context.Context, id int64)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mNoteRepositoryMockGet

	funcList          func(ctx context.Context, offset int64, limit int64) (npa1 []*model.Note, err error)
	funcListOrigin    string
	inspectFuncList   func(ctx context.Context, offset int64, limit int64)
	afterListCounter  uint64
	beforeListCounter uint64
	ListMock          mNoteRepositoryMockList

	funcUpdate          func(ctx context.Context, info *model.UpdateNote) (err error)
	funcUpdateOrigin    string
	inspectFuncUpdate   func(ctx context.Context, info *model.UpdateNote)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mNoteRepositoryMockUpdate
}

// NewNoteRepositoryMock returns a mock for mm_repository.NoteRepository
func NewNoteRepositoryMock(t minimock.Tester) *NoteRepositoryMock {
	m := &NoteRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mNoteRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*NoteRepositoryMockCreateParams{}

	m.DeleteMock = mNoteRepositoryMockDelete{mock: m}
	m.DeleteMock.callArgs = []*NoteRepositoryMockDeleteParams{}

	m.GetMock = mNoteRepositoryMockGet{mock: m}
	m.GetMock.callArgs = []*NoteRepositoryMockGetParams{}

	m.ListMock = mNoteRepositoryMockList{mock: m}
	m.ListMock.callArgs = []*NoteRepositoryMockListParams{}

	m.UpdateMock = mNoteRepositoryMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*NoteRepositoryMockUpdateParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mNoteRepositoryMockCreate struct {
	optional           bool
	mock               *NoteRepositoryMock
	defaultExpectation *NoteRepositoryMockCreateExpectation
	expectations       []*NoteRepositoryMockCreateExpectation

	callArgs []*NoteRepositoryMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// NoteRepositoryMockCreateExpectation specifies expectation struct of the NoteRepository.Create
type NoteRepositoryMockCreateExpectation struct {
	mock               *NoteRepositoryMock
	params             *NoteRepositoryMockCreateParams
	paramPtrs          *NoteRepositoryMockCreateParamPtrs
	expectationOrigins NoteRepositoryMockCreateExpectationOrigins
	results            *NoteRepositoryMockCreateResults
	returnOrigin       string
	Counter            uint64
}

// NoteRepositoryMockCreateParams contains parameters of the NoteRepository.Create
type NoteRepositoryMockCreateParams struct {
	ctx  context.Context
	info *model.NoteInfo
}

// NoteRepositoryMockCreateParamPtrs contains pointers to parameters of the NoteRepository.Create
type NoteRepositoryMockCreateParamPtrs struct {
	ctx  *context.Context
	info **model.NoteInfo
}

// NoteRepositoryMockCreateResults contains results of the NoteRepository.Create
type NoteRepositoryMockCreateResults struct {
	i1  int64
	err error
}

// NoteRepositoryMockCreateOrigins contains origins of expectations of the NoteRepository.Create
type NoteRepositoryMockCreateExpectationOrigins struct {
	origin     string
	originCtx  string
	originInfo string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mNoteRepositoryMockCreate) Optional() *mNoteRepositoryMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for NoteRepository.Create
func (mmCreate *mNoteRepositoryMockCreate) Expect(ctx context.Context, info *model.NoteInfo) *mNoteRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("NoteRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &NoteRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("NoteRepositoryMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &NoteRepositoryMockCreateParams{ctx, info}
	mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for NoteRepository.Create
func (mmCreate *mNoteRepositoryMockCreate) ExpectCtxParam1(ctx context.Context) *mNoteRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("NoteRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &NoteRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("NoteRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &NoteRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectInfoParam2 sets up expected param info for NoteRepository.Create
func (mmCreate *mNoteRepositoryMockCreate) ExpectInfoParam2(info *model.NoteInfo) *mNoteRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("NoteRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &NoteRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("NoteRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &NoteRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.info = &info
	mmCreate.defaultExpectation.expectationOrigins.originInfo = minimock.CallerInfo(1)

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the NoteRepository.Create
func (mmCreate *mNoteRepositoryMockCreate) Inspect(f func(ctx context.Context, info *model.NoteInfo)) *mNoteRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for NoteRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by NoteRepository.Create
func (mmCreate *mNoteRepositoryMockCreate) Return(i1 int64, err error) *NoteRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("NoteRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &NoteRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &NoteRepositoryMockCreateResults{i1, err}
	mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// Set uses given function f to mock the NoteRepository.Create method
func (mmCreate *mNoteRepositoryMockCreate) Set(f func(ctx context.Context, info *model.NoteInfo) (i1 int64, err error)) *NoteRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the NoteRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the NoteRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// When sets expectation for the NoteRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mNoteRepositoryMockCreate) When(ctx context.Context, info *model.NoteInfo) *NoteRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("NoteRepositoryMock.Create mock is already set by Set")
	}

	expectation := &NoteRepositoryMockCreateExpectation{
		mock:               mmCreate.mock,
		params:             &NoteRepositoryMockCreateParams{ctx, info},
		expectationOrigins: NoteRepositoryMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up NoteRepository.Create return parameters for the expectation previously defined by the When method
func (e *NoteRepositoryMockCreateExpectation) Then(i1 int64, err error) *NoteRepositoryMock {
	e.results = &NoteRepositoryMockCreateResults{i1, err}
	return e.mock
}

// Times sets number of times NoteRepository.Create should be invoked
func (mmCreate *mNoteRepositoryMockCreate) Times(n uint64) *mNoteRepositoryMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of NoteRepositoryMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreate
}

func (mmCreate *mNoteRepositoryMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements mm_repository.NoteRepository
func (mmCreate *NoteRepositoryMock) Create(ctx context.Context, info *model.NoteInfo) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	mmCreate.t.Helper()

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, info)
	}

	mm_params := NoteRepositoryMockCreateParams{ctx, info}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := NoteRepositoryMockCreateParams{ctx, info}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("NoteRepositoryMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.info != nil && !minimock.Equal(*mm_want_ptrs.info, mm_got.info) {
				mmCreate.t.Errorf("NoteRepositoryMock.Create got unexpected parameter info, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originInfo, *mm_want_ptrs.info, mm_got.info, minimock.Diff(*mm_want_ptrs.info, mm_got.info))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("NoteRepositoryMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the NoteRepositoryMock.Create")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, info)
	}
	mmCreate.t.Fatalf("Unexpected call to NoteRepositoryMock.Create. %v %v", ctx, info)
	return
}

// CreateAfterCounter returns a count of finished NoteRepositoryMock.Create invocations
func (mmCreate *NoteRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of NoteRepositoryMock.Create invocations
func (mmCreate *NoteRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to NoteRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mNoteRepositoryMockCreate) Calls() []*NoteRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*NoteRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *NoteRepositoryMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *NoteRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NoteRepositoryMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to NoteRepositoryMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to NoteRepositoryMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Errorf("Expected call to NoteRepositoryMock.Create at\n%s", m.funcCreateOrigin)
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to NoteRepositoryMock.Create at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
	}
}

type mNoteRepositoryMockDelete struct {
	optional           bool
	mock               *NoteRepositoryMock
	defaultExpectation *NoteRepositoryMockDeleteExpectation
	expectations       []*NoteRepositoryMockDeleteExpectation

	callArgs []*NoteRepositoryMockDeleteParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// NoteRepositoryMockDeleteExpectation specifies expectation struct of the NoteRepository.Delete
type NoteRepositoryMockDeleteExpectation struct {
	mock               *NoteRepositoryMock
	params             *NoteRepositoryMockDeleteParams
	paramPtrs          *NoteRepositoryMockDeleteParamPtrs
	expectationOrigins NoteRepositoryMockDeleteExpectationOrigins
	results            *NoteRepositoryMockDeleteResults
	returnOrigin       string
	Counter            uint64
}

// NoteRepositoryMockDeleteParams contains parameters of the NoteRepository.Delete
type NoteRepositoryMockDeleteParams struct {
	ctx context.Context
	id  int64
}

// NoteRepositoryMockDeleteParamPtrs contains pointers to parameters of the NoteRepository.Delete
type NoteRepositoryMockDeleteParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// NoteRepositoryMockDeleteResults contains results of the NoteRepository.Delete
type NoteRepositoryMockDeleteResults struct {
	err error
}

// NoteRepositoryMockDeleteOrigins contains origins of expectations of the NoteRepository.Delete
type NoteRepositoryMockDeleteExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mNoteRepositoryMockDelete) Optional() *mNoteRepositoryMockDelete {
	mmDelete.optional = true
	return mmDelete
}

// Expect sets up expected params for NoteRepository.Delete
func (mmDelete *mNoteRepositoryMockDelete) Expect(ctx context.Context, id int64) *mNoteRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("NoteRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &NoteRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.paramPtrs != nil {
		mmDelete.mock.t.Fatalf("NoteRepositoryMock.Delete mock is already set by ExpectParams functions")
	}

	mmDelete.defaultExpectation.params = &NoteRepositoryMockDeleteParams{ctx, id}
	mmDelete.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// ExpectCtxParam1 sets up expected param ctx for NoteRepository.Delete
func (mmDelete *mNoteRepositoryMockDelete) ExpectCtxParam1(ctx context.Context) *mNoteRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("NoteRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &NoteRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("NoteRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &NoteRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.ctx = &ctx
	mmDelete.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDelete
}

// ExpectIdParam2 sets up expected param id for NoteRepository.Delete
func (mmDelete *mNoteRepositoryMockDelete) ExpectIdParam2(id int64) *mNoteRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("NoteRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &NoteRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("NoteRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &NoteRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.id = &id
	mmDelete.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the NoteRepository.Delete
func (mmDelete *mNoteRepositoryMockDelete) Inspect(f func(ctx context.Context, id int64)) *mNoteRepositoryMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for NoteRepositoryMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by NoteRepository.Delete
func (mmDelete *mNoteRepositoryMockDelete) Return(err error) *NoteRepositoryMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("NoteRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &NoteRepositoryMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &NoteRepositoryMockDeleteResults{err}
	mmDelete.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// Set uses given function f to mock the NoteRepository.Delete method
func (mmDelete *mNoteRepositoryMockDelete) Set(f func(ctx context.Context, id int64) (err error)) *NoteRepositoryMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the NoteRepository.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the NoteRepository.Delete method")
	}

	mmDelete.mock.funcDelete = f
	mmDelete.mock.funcDeleteOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// When sets expectation for the NoteRepository.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mNoteRepositoryMockDelete) When(ctx context.Context, id int64) *NoteRepositoryMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("NoteRepositoryMock.Delete mock is already set by Set")
	}

	expectation := &NoteRepositoryMockDeleteExpectation{
		mock:               mmDelete.mock,
		params:             &NoteRepositoryMockDeleteParams{ctx, id},
		expectationOrigins: NoteRepositoryMockDeleteExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up NoteRepository.Delete return parameters for the expectation previously defined by the When method
func (e *NoteRepositoryMockDeleteExpectation) Then(err error) *NoteRepositoryMock {
	e.results = &NoteRepositoryMockDeleteResults{err}
	return e.mock
}

// Times sets number of times NoteRepository.Delete should be invoked
func (mmDelete *mNoteRepositoryMockDelete) Times(n uint64) *mNoteRepositoryMockDelete {
	if n == 0 {
		mmDelete.mock.t.Fatalf("Times of NoteRepositoryMock.Delete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelete.expectedInvocations, n)
	mmDelete.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDelete
}

func (mmDelete *mNoteRepositoryMockDelete) invocationsDone() bool {
	if len(mmDelete.expectations) == 0 && mmDelete.defaultExpectation == nil && mmDelete.mock.funcDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelete.mock.afterDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Delete implements mm_repository.NoteRepository
func (mmDelete *NoteRepositoryMock) Delete(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	mmDelete.t.Helper()

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, id)
	}

	mm_params := NoteRepositoryMockDeleteParams{ctx, id}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

		mm_got := NoteRepositoryMockDeleteParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelete.t.Errorf("NoteRepositoryMock.Delete got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDelete.t.Errorf("NoteRepositoryMock.Delete got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("NoteRepositoryMock.Delete got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDelete.DeleteMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the NoteRepositoryMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, id)
	}
	mmDelete.t.Fatalf("Unexpected call to NoteRepositoryMock.Delete. %v %v", ctx, id)
	return
}

// DeleteAfterCounter returns a count of finished NoteRepositoryMock.Delete invocations
func (mmDelete *NoteRepositoryMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of NoteRepositoryMock.Delete invocations
func (mmDelete *NoteRepositoryMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to NoteRepositoryMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mNoteRepositoryMockDelete) Calls() []*NoteRepositoryMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*NoteRepositoryMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *NoteRepositoryMock) MinimockDeleteDone() bool {
	if m.DeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMock.invocationsDone()
}

// MinimockDeleteInspect logs each unmet expectation
func (m *NoteRepositoryMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NoteRepositoryMock.Delete at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCounter := mm_atomic.LoadUint64(&m.afterDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && afterDeleteCounter < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to NoteRepositoryMock.Delete at\n%s", m.DeleteMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to NoteRepositoryMock.Delete at\n%s with params: %#v", m.DeleteMock.defaultExpectation.expectationOrigins.origin, *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && afterDeleteCounter < 1 {
		m.t.Errorf("Expected call to NoteRepositoryMock.Delete at\n%s", m.funcDeleteOrigin)
	}

	if !m.DeleteMock.invocationsDone() && afterDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to NoteRepositoryMock.Delete at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMock.expectedInvocations), m.DeleteMock.expectedInvocationsOrigin, afterDeleteCounter)
	}
}

type mNoteRepositoryMockGet struct {
	optional           bool
	mock               *NoteRepositoryMock
	defaultExpectation *NoteRepositoryMockGetExpectation
	expectations       []*NoteRepositoryMockGetExpectation

	callArgs []*NoteRepositoryMockGetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// NoteRepositoryMockGetExpectation specifies expectation struct of the NoteRepository.Get
type NoteRepositoryMockGetExpectation struct {
	mock               *NoteRepositoryMock
	params             *NoteRepositoryMockGetParams
	paramPtrs          *NoteRepositoryMockGetParamPtrs
	expectationOrigins NoteRepositoryMockGetExpectationOrigins
	results            *NoteRepositoryMockGetResults
	returnOrigin       string
	Counter            uint64
}

// NoteRepositoryMockGetParams contains parameters of the NoteRepository.Get
type NoteRepositoryMockGetParams struct {
	ctx context.Context
	id  int64
}

// NoteRepositoryMockGetParamPtrs contains pointers to parameters of the NoteRepository.Get
type NoteRepositoryMockGetParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// NoteRepositoryMockGetResults contains results of the NoteRepository.Get
type NoteRepositoryMockGetResults struct {
	np1 *model.Note
	err error
}

// NoteRepositoryMockGetOrigins contains origins of expectations of the NoteRepository.Get
type NoteRepositoryMockGetExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mNoteRepositoryMockGet) Optional() *mNoteRepositoryMockGet {
	mmGet.optional = true
	return mmGet
}

// Expect sets up expected params for NoteRepository.Get
func (mmGet *mNoteRepositoryMockGet) Expect(ctx context.Context, id int64) *mNoteRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("NoteRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &NoteRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("NoteRepositoryMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &NoteRepositoryMockGetParams{ctx, id}
	mmGet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectCtxParam1 sets up expected param ctx for NoteRepository.Get
func (mmGet *mNoteRepositoryMockGet) ExpectCtxParam1(ctx context.Context) *mNoteRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("NoteRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &NoteRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("NoteRepositoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &NoteRepositoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.ctx = &ctx
	mmGet.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGet
}

// ExpectIdParam2 sets up expected param id for NoteRepository.Get
func (mmGet *mNoteRepositoryMockGet) ExpectIdParam2(id int64) *mNoteRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("NoteRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &NoteRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("NoteRepositoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &NoteRepositoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.id = &id
	mmGet.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the NoteRepository.Get
func (mmGet *mNoteRepositoryMockGet) Inspect(f func(ctx context.Context, id int64)) *mNoteRepositoryMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for NoteRepositoryMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by NoteRepository.Get
func (mmGet *mNoteRepositoryMockGet) Return(np1 *model.Note, err error) *NoteRepositoryMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("NoteRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &NoteRepositoryMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &NoteRepositoryMockGetResults{np1, err}
	mmGet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// Set uses given function f to mock the NoteRepository.Get method
func (mmGet *mNoteRepositoryMockGet) Set(f func(ctx context.Context, id int64) (np1 *model.Note, err error)) *NoteRepositoryMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the NoteRepository.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the NoteRepository.Get method")
	}

	mmGet.mock.funcGet = f
	mmGet.mock.funcGetOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// When sets expectation for the NoteRepository.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mNoteRepositoryMockGet) When(ctx context.Context, id int64) *NoteRepositoryMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("NoteRepositoryMock.Get mock is already set by Set")
	}

	expectation := &NoteRepositoryMockGetExpectation{
		mock:               mmGet.mock,
		params:             &NoteRepositoryMockGetParams{ctx, id},
		expectationOrigins: NoteRepositoryMockGetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up NoteRepository.Get return parameters for the expectation previously defined by the When method
func (e *NoteRepositoryMockGetExpectation) Then(np1 *model.Note, err error) *NoteRepositoryMock {
	e.results = &NoteRepositoryMockGetResults{np1, err}
	return e.mock
}

// Times sets number of times NoteRepository.Get should be invoked
func (mmGet *mNoteRepositoryMockGet) Times(n uint64) *mNoteRepositoryMockGet {
	if n == 0 {
		mmGet.mock.t.Fatalf("Times of NoteRepositoryMock.Get mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGet.expectedInvocations, n)
	mmGet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGet
}

func (mmGet *mNoteRepositoryMockGet) invocationsDone() bool {
	if len(mmGet.expectations) == 0 && mmGet.defaultExpectation == nil && mmGet.mock.funcGet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGet.mock.afterGetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Get implements mm_repository.NoteRepository
func (mmGet *NoteRepositoryMock) Get(ctx context.Context, id int64) (np1 *model.Note, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	mmGet.t.Helper()

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, id)
	}

	mm_params := NoteRepositoryMockGetParams{ctx, id}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.np1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := NoteRepositoryMockGetParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGet.t.Errorf("NoteRepositoryMock.Get got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGet.t.Errorf("NoteRepositoryMock.Get got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("NoteRepositoryMock.Get got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGet.GetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the NoteRepositoryMock.Get")
		}
		return (*mm_results).np1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, id)
	}
	mmGet.t.Fatalf("Unexpected call to NoteRepositoryMock.Get. %v %v", ctx, id)
	return
}

// GetAfterCounter returns a count of finished NoteRepositoryMock.Get invocations
func (mmGet *NoteRepositoryMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of NoteRepositoryMock.Get invocations
func (mmGet *NoteRepositoryMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to NoteRepositoryMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mNoteRepositoryMockGet) Calls() []*NoteRepositoryMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*NoteRepositoryMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *NoteRepositoryMock) MinimockGetDone() bool {
	if m.GetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMock.invocationsDone()
}

// MinimockGetInspect logs each unmet expectation
func (m *NoteRepositoryMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NoteRepositoryMock.Get at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCounter := mm_atomic.LoadUint64(&m.afterGetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && afterGetCounter < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to NoteRepositoryMock.Get at\n%s", m.GetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to NoteRepositoryMock.Get at\n%s with params: %#v", m.GetMock.defaultExpectation.expectationOrigins.origin, *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && afterGetCounter < 1 {
		m.t.Errorf("Expected call to NoteRepositoryMock.Get at\n%s", m.funcGetOrigin)
	}

	if !m.GetMock.invocationsDone() && afterGetCounter > 0 {
		m.t.Errorf("Expected %d calls to NoteRepositoryMock.Get at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetMock.expectedInvocations), m.GetMock.expectedInvocationsOrigin, afterGetCounter)
	}
}

type mNoteRepositoryMockList struct {
	optional           bool
	mock               *NoteRepositoryMock
	defaultExpectation *NoteRepositoryMockListExpectation
	expectations       []*NoteRepositoryMockListExpectation

	callArgs []*NoteRepositoryMockListParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// NoteRepositoryMockListExpectation specifies expectation struct of the NoteRepository.List
type NoteRepositoryMockListExpectation struct {
	mock               *NoteRepositoryMock
	params             *NoteRepositoryMockListParams
	paramPtrs          *NoteRepositoryMockListParamPtrs
	expectationOrigins NoteRepositoryMockListExpectationOrigins
	results            *NoteRepositoryMockListResults
	returnOrigin       string
	Counter            uint64
}

// NoteRepositoryMockListParams contains parameters of the NoteRepository.List
type NoteRepositoryMockListParams struct {
	ctx    context.Context
	offset int64
	limit  int64
}

// NoteRepositoryMockListParamPtrs contains pointers to parameters of the NoteRepository.List
type NoteRepositoryMockListParamPtrs struct {
	ctx    *context.Context
	offset *int64
	limit  *int64
}

// NoteRepositoryMockListResults contains results of the NoteRepository.List
type NoteRepositoryMockListResults struct {
	npa1 []*model.Note
	err  error
}

// NoteRepositoryMockListOrigins contains origins of expectations of the NoteRepository.List
type NoteRepositoryMockListExpectationOrigins struct {
	origin       string
	originCtx    string
	originOffset string
	originLimit  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmList *mNoteRepositoryMockList) Optional() *mNoteRepositoryMockList {
	mmList.optional = true
	return mmList
}

// Expect sets up expected params for NoteRepository.List
func (mmList *mNoteRepositoryMockList) Expect(ctx context.Context, offset int64, limit int64) *mNoteRepositoryMockList {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("NoteRepositoryMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &NoteRepositoryMockListExpectation{}
	}

	if mmList.defaultExpectation.paramPtrs != nil {
		mmList.mock.t.Fatalf("NoteRepositoryMock.List mock is already set by ExpectParams functions")
	}

	mmList.defaultExpectation.params = &NoteRepositoryMockListParams{ctx, offset, limit}
	mmList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmList.expectations {
		if minimock.Equal(e.params, mmList.defaultExpectation.params) {
			mmList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmList.defaultExpectation.params)
		}
	}

	return mmList
}

// ExpectCtxParam1 sets up expected param ctx for NoteRepository.List
func (mmList *mNoteRepositoryMockList) ExpectCtxParam1(ctx context.Context) *mNoteRepositoryMockList {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("NoteRepositoryMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &NoteRepositoryMockListExpectation{}
	}

	if mmList.defaultExpectation.params != nil {
		mmList.mock.t.Fatalf("NoteRepositoryMock.List mock is already set by Expect")
	}

	if mmList.defaultExpectation.paramPtrs == nil {
		mmList.defaultExpectation.paramPtrs = &NoteRepositoryMockListParamPtrs{}
	}
	mmList.defaultExpectation.paramPtrs.ctx = &ctx
	mmList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmList
}

// ExpectOffsetParam2 sets up expected param offset for NoteRepository.List
func (mmList *mNoteRepositoryMockList) ExpectOffsetParam2(offset int64) *mNoteRepositoryMockList {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("NoteRepositoryMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &NoteRepositoryMockListExpectation{}
	}

	if mmList.defaultExpectation.params != nil {
		mmList.mock.t.Fatalf("NoteRepositoryMock.List mock is already set by Expect")
	}

	if mmList.defaultExpectation.paramPtrs == nil {
		mmList.defaultExpectation.paramPtrs = &NoteRepositoryMockListParamPtrs{}
	}
	mmList.defaultExpectation.paramPtrs.offset = &offset
	mmList.defaultExpectation.expectationOrigins.originOffset = minimock.CallerInfo(1)

	return mmList
}

// ExpectLimitParam3 sets up expected param limit for NoteRepository.List
func (mmList *mNoteRepositoryMockList) ExpectLimitParam3(limit int64) *mNoteRepositoryMockList {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("NoteRepositoryMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &NoteRepositoryMockListExpectation{}
	}

	if mmList.defaultExpectation.params != nil {
		mmList.mock.t.Fatalf("NoteRepositoryMock.List mock is already set by Expect")
	}

	if mmList.defaultExpectation.paramPtrs == nil {
		mmList.defaultExpectation.paramPtrs = &NoteRepositoryMockListParamPtrs{}
	}
	mmList.defaultExpectation.paramPtrs.limit = &limit
	mmList.defaultExpectation.expectationOrigins.originLimit = minimock.CallerInfo(1)

	return mmList
}

// Inspect accepts an inspector function that has same arguments as the NoteRepository.List
func (mmList *mNoteRepositoryMockList) Inspect(f func(ctx context.Context, offset int64, limit int64)) *mNoteRepositoryMockList {
	if mmList.mock.inspectFuncList != nil {
		mmList.mock.t.Fatalf("Inspect function is already set for NoteRepositoryMock.List")
	}

	mmList.mock.inspectFuncList = f

	return mmList
}

// Return sets up results that will be returned by NoteRepository.List
func (mmList *mNoteRepositoryMockList) Return(npa1 []*model.Note, err error) *NoteRepositoryMock {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("NoteRepositoryMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &NoteRepositoryMockListExpectation{mock: mmList.mock}
	}
	mmList.defaultExpectation.results = &NoteRepositoryMockListResults{npa1, err}
	mmList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmList.mock
}

// Set uses given function f to mock the NoteRepository.List method
func (mmList *mNoteRepositoryMockList) Set(f func(ctx context.Context, offset int64, limit int64) (npa1 []*model.Note, err error)) *NoteRepositoryMock {
	if mmList.defaultExpectation != nil {
		mmList.mock.t.Fatalf("Default expectation is already set for the NoteRepository.List method")
	}

	if len(mmList.expectations) > 0 {
		mmList.mock.t.Fatalf("Some expectations are already set for the NoteRepository.List method")
	}

	mmList.mock.funcList = f
	mmList.mock.funcListOrigin = minimock.CallerInfo(1)
	return mmList.mock
}

// When sets expectation for the NoteRepository.List which will trigger the result defined by the following
// Then helper
func (mmList *mNoteRepositoryMockList) When(ctx context.Context, offset int64, limit int64) *NoteRepositoryMockListExpectation {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("NoteRepositoryMock.List mock is already set by Set")
	}

	expectation := &NoteRepositoryMockListExpectation{
		mock:               mmList.mock,
		params:             &NoteRepositoryMockListParams{ctx, offset, limit},
		expectationOrigins: NoteRepositoryMockListExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmList.expectations = append(mmList.expectations, expectation)
	return expectation
}

// Then sets up NoteRepository.List return parameters for the expectation previously defined by the When method
func (e *NoteRepositoryMockListExpectation) Then(npa1 []*model.Note, err error) *NoteRepositoryMock {
	e.results = &NoteRepositoryMockListResults{npa1, err}
	return e.mock
}

// Times sets number of times NoteRepository.List should be invoked
func (mmList *mNoteRepositoryMockList) Times(n uint64) *mNoteRepositoryMockList {
	if n == 0 {
		mmList.mock.t.Fatalf("Times of NoteRepositoryMock.List mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmList.expectedInvocations, n)
	mmList.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmList
}

func (mmList *mNoteRepositoryMockList) invocationsDone() bool {
	if len(mmList.expectations) == 0 && mmList.defaultExpectation == nil && mmList.mock.funcList == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmList.mock.afterListCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmList.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// List implements mm_repository.NoteRepository
func (mmList *NoteRepositoryMock) List(ctx context.Context, offset int64, limit int64) (npa1 []*model.Note, err error) {
	mm_atomic.AddUint64(&mmList.beforeListCounter, 1)
	defer mm_atomic.AddUint64(&mmList.afterListCounter, 1)

	mmList.t.Helper()

	if mmList.inspectFuncList != nil {
		mmList.inspectFuncList(ctx, offset, limit)
	}

	mm_params := NoteRepositoryMockListParams{ctx, offset, limit}

	// Record call args
	mmList.ListMock.mutex.Lock()
	mmList.ListMock.callArgs = append(mmList.ListMock.callArgs, &mm_params)
	mmList.ListMock.mutex.Unlock()

	for _, e := range mmList.ListMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.npa1, e.results.err
		}
	}

	if mmList.ListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmList.ListMock.defaultExpectation.Counter, 1)
		mm_want := mmList.ListMock.defaultExpectation.params
		mm_want_ptrs := mmList.ListMock.defaultExpectation.paramPtrs

		mm_got := NoteRepositoryMockListParams{ctx, offset, limit}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmList.t.Errorf("NoteRepositoryMock.List got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmList.ListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.offset != nil && !minimock.Equal(*mm_want_ptrs.offset, mm_got.offset) {
				mmList.t.Errorf("NoteRepositoryMock.List got unexpected parameter offset, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmList.ListMock.defaultExpectation.expectationOrigins.originOffset, *mm_want_ptrs.offset, mm_got.offset, minimock.Diff(*mm_want_ptrs.offset, mm_got.offset))
			}

			if mm_want_ptrs.limit != nil && !minimock.Equal(*mm_want_ptrs.limit, mm_got.limit) {
				mmList.t.Errorf("NoteRepositoryMock.List got unexpected parameter limit, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmList.ListMock.defaultExpectation.expectationOrigins.originLimit, *mm_want_ptrs.limit, mm_got.limit, minimock.Diff(*mm_want_ptrs.limit, mm_got.limit))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmList.t.Errorf("NoteRepositoryMock.List got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmList.ListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmList.ListMock.defaultExpectation.results
		if mm_results == nil {
			mmList.t.Fatal("No results are set for the NoteRepositoryMock.List")
		}
		return (*mm_results).npa1, (*mm_results).err
	}
	if mmList.funcList != nil {
		return mmList.funcList(ctx, offset, limit)
	}
	mmList.t.Fatalf("Unexpected call to NoteRepositoryMock.List. %v %v %v", ctx, offset, limit)
	return
}

// ListAfterCounter returns a count of finished NoteRepositoryMock.List invocations
func (mmList *NoteRepositoryMock) ListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmList.afterListCounter)
}

// ListBeforeCounter returns a count of NoteRepositoryMock.List invocations
func (mmList *NoteRepositoryMock) ListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmList.beforeListCounter)
}

// Calls returns a list of arguments used in each call to NoteRepositoryMock.List.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmList *mNoteRepositoryMockList) Calls() []*NoteRepositoryMockListParams {
	mmList.mutex.RLock()

	argCopy := make([]*NoteRepositoryMockListParams, len(mmList.callArgs))
	copy(argCopy, mmList.callArgs)

	mmList.mutex.RUnlock()

	return argCopy
}

// MinimockListDone returns true if the count of the List invocations corresponds
// the number of defined expectations
func (m *NoteRepositoryMock) MinimockListDone() bool {
	if m.ListMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListMock.invocationsDone()
}

// MinimockListInspect logs each unmet expectation
func (m *NoteRepositoryMock) MinimockListInspect() {
	for _, e := range m.ListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NoteRepositoryMock.List at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListCounter := mm_atomic.LoadUint64(&m.afterListCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListMock.defaultExpectation != nil && afterListCounter < 1 {
		if m.ListMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to NoteRepositoryMock.List at\n%s", m.ListMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to NoteRepositoryMock.List at\n%s with params: %#v", m.ListMock.defaultExpectation.expectationOrigins.origin, *m.ListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcList != nil && afterListCounter < 1 {
		m.t.Errorf("Expected call to NoteRepositoryMock.List at\n%s", m.funcListOrigin)
	}

	if !m.ListMock.invocationsDone() && afterListCounter > 0 {
		m.t.Errorf("Expected %d calls to NoteRepositoryMock.List at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListMock.expectedInvocations), m.ListMock.expectedInvocationsOrigin, afterListCounter)
	}
}

type mNoteRepositoryMockUpdate struct {
	optional           bool
	mock               *NoteRepositoryMock
	defaultExpectation *NoteRepositoryMockUpdateExpectation
	expectations       []*NoteRepositoryMockUpdateExpectation

	callArgs []*NoteRepositoryMockUpdateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// NoteRepositoryMockUpdateExpectation specifies expectation struct of the NoteRepository.Update
type NoteRepositoryMockUpdateExpectation struct {
	mock               *NoteRepositoryMock
	params             *NoteRepositoryMockUpdateParams
	paramPtrs          *NoteRepositoryMockUpdateParamPtrs
	expectationOrigins NoteRepositoryMockUpdateExpectationOrigins
	results            *NoteRepositoryMockUpdateResults
	returnOrigin       string
	Counter            uint64
}

// NoteRepositoryMockUpdateParams contains parameters of the NoteRepository.Update
type NoteRepositoryMockUpdateParams struct {
	ctx  context.Context
	info *model.UpdateNote
}

// NoteRepositoryMockUpdateParamPtrs contains pointers to parameters of the NoteRepository.Update
type NoteRepositoryMockUpdateParamPtrs struct {
	ctx  *context.Context
	info **model.UpdateNote
}

// NoteRepositoryMockUpdateResults contains results of the NoteRepository.Update
type NoteRepositoryMockUpdateResults struct {
	err error
}

// NoteRepositoryMockUpdateOrigins contains origins of expectations of the NoteRepository.Update
type NoteRepositoryMockUpdateExpectationOrigins struct {
	origin     string
	originCtx  string
	originInfo string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdate *mNoteRepositoryMockUpdate) Optional() *mNoteRepositoryMockUpdate {
	mmUpdate.optional = true
	return mmUpdate
}

// Expect sets up expected params for NoteRepository.Update
func (mmUpdate *mNoteRepositoryMockUpdate) Expect(ctx context.Context, info *model.UpdateNote) *mNoteRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("NoteRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &NoteRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.paramPtrs != nil {
		mmUpdate.mock.t.Fatalf("NoteRepositoryMock.Update mock is already set by ExpectParams functions")
	}

	mmUpdate.defaultExpectation.params = &NoteRepositoryMockUpdateParams{ctx, info}
	mmUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// ExpectCtxParam1 sets up expected param ctx for NoteRepository.Update
func (mmUpdate *mNoteRepositoryMockUpdate) ExpectCtxParam1(ctx context.Context) *mNoteRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("NoteRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &NoteRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("NoteRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &NoteRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdate
}

// ExpectInfoParam2 sets up expected param info for NoteRepository.Update
func (mmUpdate *mNoteRepositoryMockUpdate) ExpectInfoParam2(info *model.UpdateNote) *mNoteRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("NoteRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &NoteRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("NoteRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &NoteRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.info = &info
	mmUpdate.defaultExpectation.expectationOrigins.originInfo = minimock.CallerInfo(1)

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the NoteRepository.Update
func (mmUpdate *mNoteRepositoryMockUpdate) Inspect(f func(ctx context.Context, info *model.UpdateNote)) *mNoteRepositoryMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for NoteRepositoryMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by NoteRepository.Update
func (mmUpdate *mNoteRepositoryMockUpdate) Return(err error) *NoteRepositoryMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("NoteRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &NoteRepositoryMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &NoteRepositoryMockUpdateResults{err}
	mmUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// Set uses given function f to mock the NoteRepository.Update method
func (mmUpdate *mNoteRepositoryMockUpdate) Set(f func(ctx context.Context, info *model.UpdateNote) (err error)) *NoteRepositoryMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the NoteRepository.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the NoteRepository.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	mmUpdate.mock.funcUpdateOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// When sets expectation for the NoteRepository.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mNoteRepositoryMockUpdate) When(ctx context.Context, info *model.UpdateNote) *NoteRepositoryMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("NoteRepositoryMock.Update mock is already set by Set")
	}

	expectation := &NoteRepositoryMockUpdateExpectation{
		mock:               mmUpdate.mock,
		params:             &NoteRepositoryMockUpdateParams{ctx, info},
		expectationOrigins: NoteRepositoryMockUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up NoteRepository.Update return parameters for the expectation previously defined by the When method
func (e *NoteRepositoryMockUpdateExpectation) Then(err error) *NoteRepositoryMock {
	e.results = &NoteRepositoryMockUpdateResults{err}
	return e.mock
}

// Times sets number of times NoteRepository.Update should be invoked
func (mmUpdate *mNoteRepositoryMockUpdate) Times(n uint64) *mNoteRepositoryMockUpdate {
	if n == 0 {
		mmUpdate.mock.t.Fatalf("Times of NoteRepositoryMock.Update mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdate.expectedInvocations, n)
	mmUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdate
}

func (mmUpdate *mNoteRepositoryMockUpdate) invocationsDone() bool {
	if len(mmUpdate.expectations) == 0 && mmUpdate.defaultExpectation == nil && mmUpdate.mock.funcUpdate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdate.mock.afterUpdateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Update implements mm_repository.NoteRepository
func (mmUpdate *NoteRepositoryMock) Update(ctx context.Context, info *model.UpdateNote) (err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	mmUpdate.t.Helper()

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, info)
	}

	mm_params := NoteRepositoryMockUpdateParams{ctx, info}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, &mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_want_ptrs := mmUpdate.UpdateMock.defaultExpectation.paramPtrs

		mm_got := NoteRepositoryMockUpdateParams{ctx, info}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdate.t.Errorf("NoteRepositoryMock.Update got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.info != nil && !minimock.Equal(*mm_want_ptrs.info, mm_got.info) {
				mmUpdate.t.Errorf("NoteRepositoryMock.Update got unexpected parameter info, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originInfo, *mm_want_ptrs.info, mm_got.info, minimock.Diff(*mm_want_ptrs.info, mm_got.info))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("NoteRepositoryMock.Update got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the NoteRepositoryMock.Update")
		}
		return (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, info)
	}
	mmUpdate.t.Fatalf("Unexpected call to NoteRepositoryMock.Update. %v %v", ctx, info)
	return
}

// UpdateAfterCounter returns a count of finished NoteRepositoryMock.Update invocations
func (mmUpdate *NoteRepositoryMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of NoteRepositoryMock.Update invocations
func (mmUpdate *NoteRepositoryMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to NoteRepositoryMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mNoteRepositoryMockUpdate) Calls() []*NoteRepositoryMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*NoteRepositoryMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *NoteRepositoryMock) MinimockUpdateDone() bool {
	if m.UpdateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateMock.invocationsDone()
}

// MinimockUpdateInspect logs each unmet expectation
func (m *NoteRepositoryMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NoteRepositoryMock.Update at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateCounter := mm_atomic.LoadUint64(&m.afterUpdateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && afterUpdateCounter < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to NoteRepositoryMock.Update at\n%s", m.UpdateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to NoteRepositoryMock.Update at\n%s with params: %#v", m.UpdateMock.defaultExpectation.expectationOrigins.origin, *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && afterUpdateCounter < 1 {
		m.t.Errorf("Expected call to NoteRepositoryMock.Update at\n%s", m.funcUpdateOrigin)
	}

	if !m.UpdateMock.invocationsDone() && afterUpdateCounter > 0 {
		m.t.Errorf("Expected %d calls to NoteRepositoryMock.Update at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateMock.expectedInvocations), m.UpdateMock.expectedInvocationsOrigin, afterUpdateCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *NoteRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockDeleteInspect()

			m.MinimockGetInspect()

			m.MinimockListInspect()

			m.MinimockUpdateInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *NoteRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *NoteRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockGetDone() &&
		m.MinimockListDone() &&
		m.MinimockUpdateDone()
}
