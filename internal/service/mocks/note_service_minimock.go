// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/xeeetu/gRPC/internal/service.NoteService -o note_service_minimock.go -n NoteServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/xeeetu/gRPC/model"
)

// NoteServiceMock implements mm_service.NoteService
type NoteServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, info *model.NoteInfo) (i1 int64, err error)
	funcCreateOrigin    string
	inspectFuncCreate   func(ctx context.Context, info *model.NoteInfo)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mNoteServiceMockCreate

	funcDelete          func(ctx context.Context, id int64) (err error)
	funcDeleteOrigin    string
	inspectFuncDelete   func(ctx context.Context, id int64)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mNoteServiceMockDelete

	funcGet          func(ctx context.Context, id int64) (np1 *model.Note, err error)
	funcGetOrigin    string
	inspectFuncGet   func(ctx context.Context, id int64)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mNoteServiceMockGet

	funcList          func(ctx context.Context, offset int64, limit int64) (npa1 []*model.Note, err error)
	funcListOrigin    string
	inspectFuncList   func(ctx context.Context, offset int64, limit int64)
	afterListCounter  uint64
	beforeListCounter uint64
	ListMock          mNoteServiceMockList

	funcUpdate          func(ctx context.Context, info *model.UpdateNote) (err error)
	funcUpdateOrigin    string
	inspectFuncUpdate   func(ctx context.Context, info *model.UpdateNote)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mNoteServiceMockUpdate
}

// NewNoteServiceMock returns a mock for mm_service.NoteService
func NewNoteServiceMock(t minimock.Tester) *NoteServiceMock {
	m := &NoteServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mNoteServiceMockCreate{mock: m}
	m.CreateMock.callArgs = []*NoteServiceMockCreateParams{}

	m.DeleteMock = mNoteServiceMockDelete{mock: m}
	m.DeleteMock.callArgs = []*NoteServiceMockDeleteParams{}

	m.GetMock = mNoteServiceMockGet{mock: m}
	m.GetMock.callArgs = []*NoteServiceMockGetParams{}

	m.ListMock = mNoteServiceMockList{mock: m}
	m.ListMock.callArgs = []*NoteServiceMockListParams{}

	m.UpdateMock = mNoteServiceMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*NoteServiceMockUpdateParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mNoteServiceMockCreate struct {
	optional           bool
	mock               *NoteServiceMock
	defaultExpectation *NoteServiceMockCreateExpectation
	expectations       []*NoteServiceMockCreateExpectation

	callArgs []*NoteServiceMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// NoteServiceMockCreateExpectation specifies expectation struct of the NoteService.Create
type NoteServiceMockCreateExpectation struct {
	mock               *NoteServiceMock
	params             *NoteServiceMockCreateParams
	paramPtrs          *NoteServiceMockCreateParamPtrs
	expectationOrigins NoteServiceMockCreateExpectationOrigins
	results            *NoteServiceMockCreateResults
	returnOrigin       string
	Counter            uint64
}

// NoteServiceMockCreateParams contains parameters of the NoteService.Create
type NoteServiceMockCreateParams struct {
	ctx  context.Context
	info *model.NoteInfo
}

// NoteServiceMockCreateParamPtrs contains pointers to parameters of the NoteService.Create
type NoteServiceMockCreateParamPtrs struct {
	ctx  *context.Context
	info **model.NoteInfo
}

// NoteServiceMockCreateResults contains results of the NoteService.Create
type NoteServiceMockCreateResults struct {
	i1  int64
	err error
}

// NoteServiceMockCreateOrigins contains origins of expectations of the NoteService.Create
type NoteServiceMockCreateExpectationOrigins struct {
	origin     string
	originCtx  string
	originInfo string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mNoteServiceMockCreate) Optional() *mNoteServiceMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for NoteService.Create
func (mmCreate *mNoteServiceMockCreate) Expect(ctx context.Context, info *model.NoteInfo) *mNoteServiceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("NoteServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &NoteServiceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("NoteServiceMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &NoteServiceMockCreateParams{ctx, info}
	mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for NoteService.Create
func (mmCreate *mNoteServiceMockCreate) ExpectCtxParam1(ctx context.Context) *mNoteServiceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("NoteServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &NoteServiceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("NoteServiceMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &NoteServiceMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectInfoParam2 sets up expected param info for NoteService.Create
func (mmCreate *mNoteServiceMockCreate) ExpectInfoParam2(info *model.NoteInfo) *mNoteServiceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("NoteServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &NoteServiceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("NoteServiceMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &NoteServiceMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.info = &info
	mmCreate.defaultExpectation.expectationOrigins.originInfo = minimock.CallerInfo(1)

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the NoteService.Create
func (mmCreate *mNoteServiceMockCreate) Inspect(f func(ctx context.Context, info *model.NoteInfo)) *mNoteServiceMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for NoteServiceMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by NoteService.Create
func (mmCreate *mNoteServiceMockCreate) Return(i1 int64, err error) *NoteServiceMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("NoteServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &NoteServiceMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &NoteServiceMockCreateResults{i1, err}
	mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// Set uses given function f to mock the NoteService.Create method
func (mmCreate *mNoteServiceMockCreate) Set(f func(ctx context.Context, info *model.NoteInfo) (i1 int64, err error)) *NoteServiceMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the NoteService.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the NoteService.Create method")
	}

	mmCreate.mock.funcCreate = f
	mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// When sets expectation for the NoteService.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mNoteServiceMockCreate) When(ctx context.Context, info *model.NoteInfo) *NoteServiceMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("NoteServiceMock.Create mock is already set by Set")
	}

	expectation := &NoteServiceMockCreateExpectation{
		mock:               mmCreate.mock,
		params:             &NoteServiceMockCreateParams{ctx, info},
		expectationOrigins: NoteServiceMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up NoteService.Create return parameters for the expectation previously defined by the When method
func (e *NoteServiceMockCreateExpectation) Then(i1 int64, err error) *NoteServiceMock {
	e.results = &NoteServiceMockCreateResults{i1, err}
	return e.mock
}

// Times sets number of times NoteService.Create should be invoked
func (mmCreate *mNoteServiceMockCreate) Times(n uint64) *mNoteServiceMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of NoteServiceMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreate
}

func (mmCreate *mNoteServiceMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements mm_service.NoteService
func (mmCreate *NoteServiceMock) Create(ctx context.Context, info *model.NoteInfo) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	mmCreate.t.Helper()

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, info)
	}

	mm_params := NoteServiceMockCreateParams{ctx, info}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := NoteServiceMockCreateParams{ctx, info}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("NoteServiceMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.info != nil && !minimock.Equal(*mm_want_ptrs.info, mm_got.info) {
				mmCreate.t.Errorf("NoteServiceMock.Create got unexpected parameter info, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originInfo, *mm_want_ptrs.info, mm_got.info, minimock.Diff(*mm_want_ptrs.info, mm_got.info))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("NoteServiceMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the NoteServiceMock.Create")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, info)
	}
	mmCreate.t.Fatalf("Unexpected call to NoteServiceMock.Create. %v %v", ctx, info)
	return
}

// CreateAfterCounter returns a count of finished NoteServiceMock.Create invocations
func (mmCreate *NoteServiceMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of NoteServiceMock.Create invocations
func (mmCreate *NoteServiceMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to NoteServiceMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mNoteServiceMockCreate) Calls() []*NoteServiceMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*NoteServiceMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *NoteServiceMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *NoteServiceMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NoteServiceMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to NoteServiceMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to NoteServiceMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Errorf("Expected call to NoteServiceMock.Create at\n%s", m.funcCreateOrigin)
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to NoteServiceMock.Create at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
	}
}

type mNoteServiceMockDelete struct {
	optional           bool
	mock               *NoteServiceMock
	defaultExpectation *NoteServiceMockDeleteExpectation
	expectations       []*NoteServiceMockDeleteExpectation

	callArgs []*NoteServiceMockDeleteParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// NoteServiceMockDeleteExpectation specifies expectation struct of the NoteService.Delete
type NoteServiceMockDeleteExpectation struct {
	mock               *NoteServiceMock
	params             *NoteServiceMockDeleteParams
	paramPtrs          *NoteServiceMockDeleteParamPtrs
	expectationOrigins NoteServiceMockDeleteExpectationOrigins
	results            *NoteServiceMockDeleteResults
	returnOrigin       string
	Counter            uint64
}

// NoteServiceMockDeleteParams contains parameters of the NoteService.Delete
type NoteServiceMockDeleteParams struct {
	ctx context.Context
	id  int64
}

// NoteServiceMockDeleteParamPtrs contains pointers to parameters of the NoteService.Delete
type NoteServiceMockDeleteParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// NoteServiceMockDeleteResults contains results of the NoteService.Delete
type NoteServiceMockDeleteResults struct {
	err error
}

// NoteServiceMockDeleteOrigins contains origins of expectations of the NoteService.Delete
type NoteServiceMockDeleteExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mNoteServiceMockDelete) Optional() *mNoteServiceMockDelete {
	mmDelete.optional = true
	return mmDelete
}

// Expect sets up expected params for NoteService.Delete
func (mmDelete *mNoteServiceMockDelete) Expect(ctx context.Context, id int64) *mNoteServiceMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("NoteServiceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &NoteServiceMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.paramPtrs != nil {
		mmDelete.mock.t.Fatalf("NoteServiceMock.Delete mock is already set by ExpectParams functions")
	}

	mmDelete.defaultExpectation.params = &NoteServiceMockDeleteParams{ctx, id}
	mmDelete.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// ExpectCtxParam1 sets up expected param ctx for NoteService.Delete
func (mmDelete *mNoteServiceMockDelete) ExpectCtxParam1(ctx context.Context) *mNoteServiceMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("NoteServiceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &NoteServiceMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("NoteServiceMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &NoteServiceMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.ctx = &ctx
	mmDelete.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDelete
}

// ExpectIdParam2 sets up expected param id for NoteService.Delete
func (mmDelete *mNoteServiceMockDelete) ExpectIdParam2(id int64) *mNoteServiceMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("NoteServiceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &NoteServiceMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("NoteServiceMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &NoteServiceMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.id = &id
	mmDelete.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the NoteService.Delete
func (mmDelete *mNoteServiceMockDelete) Inspect(f func(ctx context.Context, id int64)) *mNoteServiceMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for NoteServiceMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by NoteService.Delete
func (mmDelete *mNoteServiceMockDelete) Return(err error) *NoteServiceMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("NoteServiceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &NoteServiceMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &NoteServiceMockDeleteResults{err}
	mmDelete.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// Set uses given function f to mock the NoteService.Delete method
func (mmDelete *mNoteServiceMockDelete) Set(f func(ctx context.Context, id int64) (err error)) *NoteServiceMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the NoteService.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the NoteService.Delete method")
	}

	mmDelete.mock.funcDelete = f
	mmDelete.mock.funcDeleteOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// When sets expectation for the NoteService.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mNoteServiceMockDelete) When(ctx context.Context, id int64) *NoteServiceMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("NoteServiceMock.Delete mock is already set by Set")
	}

	expectation := &NoteServiceMockDeleteExpectation{
		mock:               mmDelete.mock,
		params:             &NoteServiceMockDeleteParams{ctx, id},
		expectationOrigins: NoteServiceMockDeleteExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up NoteService.Delete return parameters for the expectation previously defined by the When method
func (e *NoteServiceMockDeleteExpectation) Then(err error) *NoteServiceMock {
	e.results = &NoteServiceMockDeleteResults{err}
	return e.mock
}

// Times sets number of times NoteService.Delete should be invoked
func (mmDelete *mNoteServiceMockDelete) Times(n uint64) *mNoteServiceMockDelete {
	if n == 0 {
		mmDelete.mock.t.Fatalf("Times of NoteServiceMock.Delete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelete.expectedInvocations, n)
	mmDelete.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDelete
}

func (mmDelete *mNoteServiceMockDelete) invocationsDone() bool {
	if len(mmDelete.expectations) == 0 && mmDelete.defaultExpectation == nil && mmDelete.mock.funcDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelete.mock.afterDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Delete implements mm_service.NoteService
func (mmDelete *NoteServiceMock) Delete(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	mmDelete.t.Helper()

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, id)
	}

	mm_params := NoteServiceMockDeleteParams{ctx, id}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

		mm_got := NoteServiceMockDeleteParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelete.t.Errorf("NoteServiceMock.Delete got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDelete.t.Errorf("NoteServiceMock.Delete got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("NoteServiceMock.Delete got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDelete.DeleteMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the NoteServiceMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, id)
	}
	mmDelete.t.Fatalf("Unexpected call to NoteServiceMock.Delete. %v %v", ctx, id)
	return
}

// DeleteAfterCounter returns a count of finished NoteServiceMock.Delete invocations
func (mmDelete *NoteServiceMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of NoteServiceMock.Delete invocations
func (mmDelete *NoteServiceMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to NoteServiceMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mNoteServiceMockDelete) Calls() []*NoteServiceMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*NoteServiceMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *NoteServiceMock) MinimockDeleteDone() bool {
	if m.DeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMock.invocationsDone()
}

// MinimockDeleteInspect logs each unmet expectation
func (m *NoteServiceMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NoteServiceMock.Delete at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCounter := mm_atomic.LoadUint64(&m.afterDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && afterDeleteCounter < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to NoteServiceMock.Delete at\n%s", m.DeleteMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to NoteServiceMock.Delete at\n%s with params: %#v", m.DeleteMock.defaultExpectation.expectationOrigins.origin, *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && afterDeleteCounter < 1 {
		m.t.Errorf("Expected call to NoteServiceMock.Delete at\n%s", m.funcDeleteOrigin)
	}

	if !m.DeleteMock.invocationsDone() && afterDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to NoteServiceMock.Delete at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMock.expectedInvocations), m.DeleteMock.expectedInvocationsOrigin, afterDeleteCounter)
	}
}

type mNoteServiceMockGet struct {
	optional           bool
	mock               *NoteServiceMock
	defaultExpectation *NoteServiceMockGetExpectation
	expectations       []*NoteServiceMockGetExpectation

	callArgs []*NoteServiceMockGetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// NoteServiceMockGetExpectation specifies expectation struct of the NoteService.Get
type NoteServiceMockGetExpectation struct {
	mock               *NoteServiceMock
	params             *NoteServiceMockGetParams
	paramPtrs          *NoteServiceMockGetParamPtrs
	expectationOrigins NoteServiceMockGetExpectationOrigins
	results            *NoteServiceMockGetResults
	returnOrigin       string
	Counter            uint64
}

// NoteServiceMockGetParams contains parameters of the NoteService.Get
type NoteServiceMockGetParams struct {
	ctx context.Context
	id  int64
}

// NoteServiceMockGetParamPtrs contains pointers to parameters of the NoteService.Get
type NoteServiceMockGetParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// NoteServiceMockGetResults contains results of the NoteService.Get
type NoteServiceMockGetResults struct {
	np1 *model.Note
	err error
}

// NoteServiceMockGetOrigins contains origins of expectations of the NoteService.Get
type NoteServiceMockGetExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mNoteServiceMockGet) Optional() *mNoteServiceMockGet {
	mmGet.optional = true
	return mmGet
}

// Expect sets up expected params for NoteService.Get
func (mmGet *mNoteServiceMockGet) Expect(ctx context.Context, id int64) *mNoteServiceMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("NoteServiceMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &NoteServiceMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("NoteServiceMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &NoteServiceMockGetParams{ctx, id}
	mmGet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectCtxParam1 sets up expected param ctx for NoteService.Get
func (mmGet *mNoteServiceMockGet) ExpectCtxParam1(ctx context.Context) *mNoteServiceMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("NoteServiceMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &NoteServiceMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("NoteServiceMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &NoteServiceMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.ctx = &ctx
	mmGet.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGet
}

// ExpectIdParam2 sets up expected param id for NoteService.Get
func (mmGet *mNoteServiceMockGet) ExpectIdParam2(id int64) *mNoteServiceMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("NoteServiceMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &NoteServiceMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("NoteServiceMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &NoteServiceMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.id = &id
	mmGet.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the NoteService.Get
func (mmGet *mNoteServiceMockGet) Inspect(f func(ctx context.Context, id int64)) *mNoteServiceMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for NoteServiceMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by NoteService.Get
func (mmGet *mNoteServiceMockGet) Return(np1 *model.Note, err error) *NoteServiceMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("NoteServiceMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &NoteServiceMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &NoteServiceMockGetResults{np1, err}
	mmGet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// Set uses given function f to mock the NoteService.Get method
func (mmGet *mNoteServiceMockGet) Set(f func(ctx context.Context, id int64) (np1 *model.Note, err error)) *NoteServiceMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the NoteService.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the NoteService.Get method")
	}

	mmGet.mock.funcGet = f
	mmGet.mock.funcGetOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// When sets expectation for the NoteService.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mNoteServiceMockGet) When(ctx context.Context, id int64) *NoteServiceMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("NoteServiceMock.Get mock is already set by Set")
	}

	expectation := &NoteServiceMockGetExpectation{
		mock:               mmGet.mock,
		params:             &NoteServiceMockGetParams{ctx, id},
		expectationOrigins: NoteServiceMockGetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up NoteService.Get return parameters for the expectation previously defined by the When method
func (e *NoteServiceMockGetExpectation) Then(np1 *model.Note, err error) *NoteServiceMock {
	e.results = &NoteServiceMockGetResults{np1, err}
	return e.mock
}

// Times sets number of times NoteService.Get should be invoked
func (mmGet *mNoteServiceMockGet) Times(n uint64) *mNoteServiceMockGet {
	if n == 0 {
		mmGet.mock.t.Fatalf("Times of NoteServiceMock.Get mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGet.expectedInvocations, n)
	mmGet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGet
}

func (mmGet *mNoteServiceMockGet) invocationsDone() bool {
	if len(mmGet.expectations) == 0 && mmGet.defaultExpectation == nil && mmGet.mock.funcGet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGet.mock.afterGetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Get implements mm_service.NoteService
func (mmGet *NoteServiceMock) Get(ctx context.Context, id int64) (np1 *model.Note, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	mmGet.t.Helper()

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, id)
	}

	mm_params := NoteServiceMockGetParams{ctx, id}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.np1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := NoteServiceMockGetParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGet.t.Errorf("NoteServiceMock.Get got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGet.t.Errorf("NoteServiceMock.Get got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("NoteServiceMock.Get got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGet.GetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the NoteServiceMock.Get")
		}
		return (*mm_results).np1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, id)
	}
	mmGet.t.Fatalf("Unexpected call to NoteServiceMock.Get. %v %v", ctx, id)
	return
}

// GetAfterCounter returns a count of finished NoteServiceMock.Get invocations
func (mmGet *NoteServiceMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of NoteServiceMock.Get invocations
func (mmGet *NoteServiceMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to NoteServiceMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mNoteServiceMockGet) Calls() []*NoteServiceMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*NoteServiceMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *NoteServiceMock) MinimockGetDone() bool {
	if m.GetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMock.invocationsDone()
}

// MinimockGetInspect logs each unmet expectation
func (m *NoteServiceMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NoteServiceMock.Get at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCounter := mm_atomic.LoadUint64(&m.afterGetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && afterGetCounter < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to NoteServiceMock.Get at\n%s", m.GetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to NoteServiceMock.Get at\n%s with params: %#v", m.GetMock.defaultExpectation.expectationOrigins.origin, *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && afterGetCounter < 1 {
		m.t.Errorf("Expected call to NoteServiceMock.Get at\n%s", m.funcGetOrigin)
	}

	if !m.GetMock.invocationsDone() && afterGetCounter > 0 {
		m.t.Errorf("Expected %d calls to NoteServiceMock.Get at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetMock.expectedInvocations), m.GetMock.expectedInvocationsOrigin, afterGetCounter)
	}
}

type mNoteServiceMockList struct {
	optional           bool
	mock               *NoteServiceMock
	defaultExpectation *NoteServiceMockListExpectation
	expectations       []*NoteServiceMockListExpectation

	callArgs []*NoteServiceMockListParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// NoteServiceMockListExpectation specifies expectation struct of the NoteService.List
type NoteServiceMockListExpectation struct {
	mock               *NoteServiceMock
	params             *NoteServiceMockListParams
	paramPtrs          *NoteServiceMockListParamPtrs
	expectationOrigins NoteServiceMockListExpectationOrigins
	results            *NoteServiceMockListResults
	returnOrigin       string
	Counter            uint64
}

// NoteServiceMockListParams contains parameters of the NoteService.List
type NoteServiceMockListParams struct {
	ctx    context.Context
	offset int64
	limit  int64
}

// NoteServiceMockListParamPtrs contains pointers to parameters of the NoteService.List
type NoteServiceMockListParamPtrs struct {
	ctx    *context.Context
	offset *int64
	limit  *int64
}

// NoteServiceMockListResults contains results of the NoteService.List
type NoteServiceMockListResults struct {
	npa1 []*model.Note
	err  error
}

// NoteServiceMockListOrigins contains origins of expectations of the NoteService.List
type NoteServiceMockListExpectationOrigins struct {
	origin       string
	originCtx    string
	originOffset string
	originLimit  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmList *mNoteServiceMockList) Optional() *mNoteServiceMockList {
	mmList.optional = true
	return mmList
}

// Expect sets up expected params for NoteService.List
func (mmList *mNoteServiceMockList) Expect(ctx context.Context, offset int64, limit int64) *mNoteServiceMockList {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("NoteServiceMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &NoteServiceMockListExpectation{}
	}

	if mmList.defaultExpectation.paramPtrs != nil {
		mmList.mock.t.Fatalf("NoteServiceMock.List mock is already set by ExpectParams functions")
	}

	mmList.defaultExpectation.params = &NoteServiceMockListParams{ctx, offset, limit}
	mmList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmList.expectations {
		if minimock.Equal(e.params, mmList.defaultExpectation.params) {
			mmList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmList.defaultExpectation.params)
		}
	}

	return mmList
}

// ExpectCtxParam1 sets up expected param ctx for NoteService.List
func (mmList *mNoteServiceMockList) ExpectCtxParam1(ctx context.Context) *mNoteServiceMockList {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("NoteServiceMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &NoteServiceMockListExpectation{}
	}

	if mmList.defaultExpectation.params != nil {
		mmList.mock.t.Fatalf("NoteServiceMock.List mock is already set by Expect")
	}

	if mmList.defaultExpectation.paramPtrs == nil {
		mmList.defaultExpectation.paramPtrs = &NoteServiceMockListParamPtrs{}
	}
	mmList.defaultExpectation.paramPtrs.ctx = &ctx
	mmList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmList
}

// ExpectOffsetParam2 sets up expected param offset for NoteService.List
func (mmList *mNoteServiceMockList) ExpectOffsetParam2(offset int64) *mNoteServiceMockList {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("NoteServiceMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &NoteServiceMockListExpectation{}
	}

	if mmList.defaultExpectation.params != nil {
		mmList.mock.t.Fatalf("NoteServiceMock.List mock is already set by Expect")
	}

	if mmList.defaultExpectation.paramPtrs == nil {
		mmList.defaultExpectation.paramPtrs = &NoteServiceMockListParamPtrs{}
	}
	mmList.defaultExpectation.paramPtrs.offset = &offset
	mmList.defaultExpectation.expectationOrigins.originOffset = minimock.CallerInfo(1)

	return mmList
}

// ExpectLimitParam3 sets up expected param limit for NoteService.List
func (mmList *mNoteServiceMockList) ExpectLimitParam3(limit int64) *mNoteServiceMockList {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("NoteServiceMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &NoteServiceMockListExpectation{}
	}

	if mmList.defaultExpectation.params != nil {
		mmList.mock.t.Fatalf("NoteServiceMock.List mock is already set by Expect")
	}

	if mmList.defaultExpectation.paramPtrs == nil {
		mmList.defaultExpectation.paramPtrs = &NoteServiceMockListParamPtrs{}
	}
	mmList.defaultExpectation.paramPtrs.limit = &limit
	mmList.defaultExpectation.expectationOrigins.originLimit = minimock.CallerInfo(1)

	return mmList
}

// Inspect accepts an inspector function that has same arguments as the NoteService.List
func (mmList *mNoteServiceMockList) Inspect(f func(ctx context.Context, offset int64, limit int64)) *mNoteServiceMockList {
	if mmList.mock.inspectFuncList != nil {
		mmList.mock.t.Fatalf("Inspect function is already set for NoteServiceMock.List")
	}

	mmList.mock.inspectFuncList = f

	return mmList
}

// Return sets up results that will be returned by NoteService.List
func (mmList *mNoteServiceMockList) Return(npa1 []*model.Note, err error) *NoteServiceMock {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("NoteServiceMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &NoteServiceMockListExpectation{mock: mmList.mock}
	}
	mmList.defaultExpectation.results = &NoteServiceMockListResults{npa1, err}
	mmList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmList.mock
}

// Set uses given function f to mock the NoteService.List method
func (mmList *mNoteServiceMockList) Set(f func(ctx context.Context, offset int64, limit int64) (npa1 []*model.Note, err error)) *NoteServiceMock {
	if mmList.defaultExpectation != nil {
		mmList.mock.t.Fatalf("Default expectation is already set for the NoteService.List method")
	}

	if len(mmList.expectations) > 0 {
		mmList.mock.t.Fatalf("Some expectations are already set for the NoteService.List method")
	}

	mmList.mock.funcList = f
	mmList.mock.funcListOrigin = minimock.CallerInfo(1)
	return mmList.mock
}

// When sets expectation for the NoteService.List which will trigger the result defined by the following
// Then helper
func (mmList *mNoteServiceMockList) When(ctx context.Context, offset int64, limit int64) *NoteServiceMockListExpectation {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("NoteServiceMock.List mock is already set by Set")
	}

	expectation := &NoteServiceMockListExpectation{
		mock:               mmList.mock,
		params:             &NoteServiceMockListParams{ctx, offset, limit},
		expectationOrigins: NoteServiceMockListExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmList.expectations = append(mmList.expectations, expectation)
	return expectation
}

// Then sets up NoteService.List return parameters for the expectation previously defined by the When method
func (e *NoteServiceMockListExpectation) Then(npa1 []*model.Note, err error) *NoteServiceMock {
	e.results = &NoteServiceMockListResults{npa1, err}
	return e.mock
}

// Times sets number of times NoteService.List should be invoked
func (mmList *mNoteServiceMockList) Times(n uint64) *mNoteServiceMockList {
	if n == 0 {
		mmList.mock.t.Fatalf("Times of NoteServiceMock.List mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmList.expectedInvocations, n)
	mmList.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmList
}

func (mmList *mNoteServiceMockList) invocationsDone() bool {
	if len(mmList.expectations) == 0 && mmList.defaultExpectation == nil && mmList.mock.funcList == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmList.mock.afterListCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmList.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// List implements mm_service.NoteService
func (mmList *NoteServiceMock) List(ctx context.Context, offset int64, limit int64) (npa1 []*model.Note, err error) {
	mm_atomic.AddUint64(&mmList.beforeListCounter, 1)
	defer mm_atomic.AddUint64(&mmList.afterListCounter, 1)

	mmList.t.Helper()

	if mmList.inspectFuncList != nil {
		mmList.inspectFuncList(ctx, offset, limit)
	}

	mm_params := NoteServiceMockListParams{ctx, offset, limit}

	// Record call args
	mmList.ListMock.mutex.Lock()
	mmList.ListMock.callArgs = append(mmList.ListMock.callArgs, &mm_params)
	mmList.ListMock.mutex.Unlock()

	for _, e := range mmList.ListMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.npa1, e.results.err
		}
	}

	if mmList.ListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmList.ListMock.defaultExpectation.Counter, 1)
		mm_want := mmList.ListMock.defaultExpectation.params
		mm_want_ptrs := mmList.ListMock.defaultExpectation.paramPtrs

		mm_got := NoteServiceMockListParams{ctx, offset, limit}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmList.t.Errorf("NoteServiceMock.List got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmList.ListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.offset != nil && !minimock.Equal(*mm_want_ptrs.offset, mm_got.offset) {
				mmList.t.Errorf("NoteServiceMock.List got unexpected parameter offset, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmList.ListMock.defaultExpectation.expectationOrigins.originOffset, *mm_want_ptrs.offset, mm_got.offset, minimock.Diff(*mm_want_ptrs.offset, mm_got.offset))
			}

			if mm_want_ptrs.limit != nil && !minimock.Equal(*mm_want_ptrs.limit, mm_got.limit) {
				mmList.t.Errorf("NoteServiceMock.List got unexpected parameter limit, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmList.ListMock.defaultExpectation.expectationOrigins.originLimit, *mm_want_ptrs.limit, mm_got.limit, minimock.Diff(*mm_want_ptrs.limit, mm_got.limit))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmList.t.Errorf("NoteServiceMock.List got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmList.ListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmList.ListMock.defaultExpectation.results
		if mm_results == nil {
			mmList.t.Fatal("No results are set for the NoteServiceMock.List")
		}
		return (*mm_results).npa1, (*mm_results).err
	}
	if mmList.funcList != nil {
		return mmList.funcList(ctx, offset, limit)
	}
	mmList.t.Fatalf("Unexpected call to NoteServiceMock.List. %v %v %v", ctx, offset, limit)
	return
}

// ListAfterCounter returns a count of finished NoteServiceMock.List invocations
func (mmList *NoteServiceMock) ListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmList.afterListCounter)
}

// ListBeforeCounter returns a count of NoteServiceMock.List invocations
func (mmList *NoteServiceMock) ListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmList.beforeListCounter)
}

// Calls returns a list of arguments used in each call to NoteServiceMock.List.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmList *mNoteServiceMockList) Calls() []*NoteServiceMockListParams {
	mmList.mutex.RLock()

	argCopy := make([]*NoteServiceMockListParams, len(mmList.callArgs))
	copy(argCopy, mmList.callArgs)

	mmList.mutex.RUnlock()

	return argCopy
}

// MinimockListDone returns true if the count of the List invocations corresponds
// the number of defined expectations
func (m *NoteServiceMock) MinimockListDone() bool {
	if m.ListMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListMock.invocationsDone()
}

// MinimockListInspect logs each unmet expectation
func (m *NoteServiceMock) MinimockListInspect() {
	for _, e := range m.ListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NoteServiceMock.List at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListCounter := mm_atomic.LoadUint64(&m.afterListCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListMock.defaultExpectation != nil && afterListCounter < 1 {
		if m.ListMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to NoteServiceMock.List at\n%s", m.ListMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to NoteServiceMock.List at\n%s with params: %#v", m.ListMock.defaultExpectation.expectationOrigins.origin, *m.ListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcList != nil && afterListCounter < 1 {
		m.t.Errorf("Expected call to NoteServiceMock.List at\n%s", m.funcListOrigin)
	}

	if !m.ListMock.invocationsDone() && afterListCounter > 0 {
		m.t.Errorf("Expected %d calls to NoteServiceMock.List at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListMock.expectedInvocations), m.ListMock.expectedInvocationsOrigin, afterListCounter)
	}
}

type mNoteServiceMockUpdate struct {
	optional           bool
	mock               *NoteServiceMock
	defaultExpectation *NoteServiceMockUpdateExpectation
	expectations       []*NoteServiceMockUpdateExpectation

	callArgs []*NoteServiceMockUpdateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// NoteServiceMockUpdateExpectation specifies expectation struct of the NoteService.Update
type NoteServiceMockUpdateExpectation struct {
	mock               *NoteServiceMock
	params             *NoteServiceMockUpdateParams
	paramPtrs          *NoteServiceMockUpdateParamPtrs
	expectationOrigins NoteServiceMockUpdateExpectationOrigins
	results            *NoteServiceMockUpdateResults
	returnOrigin       string
	Counter            uint64
}

// NoteServiceMockUpdateParams contains parameters of the NoteService.Update
type NoteServiceMockUpdateParams struct {
	ctx  context.Context
	info *model.UpdateNote
}

// NoteServiceMockUpdateParamPtrs contains pointers to parameters of the NoteService.Update
type NoteServiceMockUpdateParamPtrs struct {
	ctx  *context.Context
	info **model.UpdateNote
}

// NoteServiceMockUpdateResults contains results of the NoteService.Update
type NoteServiceMockUpdateResults struct {
	err error
}

// NoteServiceMockUpdateOrigins contains origins of expectations of the NoteService.Update
type NoteServiceMockUpdateExpectationOrigins struct {
	origin     string
	originCtx  string
	originInfo string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdate *mNoteServiceMockUpdate) Optional() *mNoteServiceMockUpdate {
	mmUpdate.optional = true
	return mmUpdate
}

// Expect sets up expected params for NoteService.Update
func (mmUpdate *mNoteServiceMockUpdate) Expect(ctx context.Context, info *model.UpdateNote) *mNoteServiceMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("NoteServiceMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &NoteServiceMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.paramPtrs != nil {
		mmUpdate.mock.t.Fatalf("NoteServiceMock.Update mock is already set by ExpectParams functions")
	}

	mmUpdate.defaultExpectation.params = &NoteServiceMockUpdateParams{ctx, info}
	mmUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// ExpectCtxParam1 sets up expected param ctx for NoteService.Update
func (mmUpdate *mNoteServiceMockUpdate) ExpectCtxParam1(ctx context.Context) *mNoteServiceMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("NoteServiceMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &NoteServiceMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("NoteServiceMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &NoteServiceMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdate
}

// ExpectInfoParam2 sets up expected param info for NoteService.Update
func (mmUpdate *mNoteServiceMockUpdate) ExpectInfoParam2(info *model.UpdateNote) *mNoteServiceMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("NoteServiceMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &NoteServiceMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("NoteServiceMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &NoteServiceMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.info = &info
	mmUpdate.defaultExpectation.expectationOrigins.originInfo = minimock.CallerInfo(1)

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the NoteService.Update
func (mmUpdate *mNoteServiceMockUpdate) Inspect(f func(ctx context.Context, info *model.UpdateNote)) *mNoteServiceMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for NoteServiceMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by NoteService.Update
func (mmUpdate *mNoteServiceMockUpdate) Return(err error) *NoteServiceMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("NoteServiceMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &NoteServiceMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &NoteServiceMockUpdateResults{err}
	mmUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// Set uses given function f to mock the NoteService.Update method
func (mmUpdate *mNoteServiceMockUpdate) Set(f func(ctx context.Context, info *model.UpdateNote) (err error)) *NoteServiceMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the NoteService.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the NoteService.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	mmUpdate.mock.funcUpdateOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// When sets expectation for the NoteService.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mNoteServiceMockUpdate) When(ctx context.Context, info *model.UpdateNote) *NoteServiceMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("NoteServiceMock.Update mock is already set by Set")
	}

	expectation := &NoteServiceMockUpdateExpectation{
		mock:               mmUpdate.mock,
		params:             &NoteServiceMockUpdateParams{ctx, info},
		expectationOrigins: NoteServiceMockUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up NoteService.Update return parameters for the expectation previously defined by the When method
func (e *NoteServiceMockUpdateExpectation) Then(err error) *NoteServiceMock {
	e.results = &NoteServiceMockUpdateResults{err}
	return e.mock
}

// Times sets number of times NoteService.Update should be invoked
func (mmUpdate *mNoteServiceMockUpdate) Times(n uint64) *mNoteServiceMockUpdate {
	if n == 0 {
		mmUpdate.mock.t.Fatalf("Times of NoteServiceMock.Update mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdate.expectedInvocations, n)
	mmUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdate
}

func (mmUpdate *mNoteServiceMockUpdate) invocationsDone() bool {
	if len(mmUpdate.expectations) == 0 && mmUpdate.defaultExpectation == nil && mmUpdate.mock.funcUpdate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdate.mock.afterUpdateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Update implements mm_service.NoteService
func (mmUpdate *NoteServiceMock) Update(ctx context.Context, info *model.UpdateNote) (err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	mmUpdate.t.Helper()

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, info)
	}

	mm_params := NoteServiceMockUpdateParams{ctx, info}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, &mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_want_ptrs := mmUpdate.UpdateMock.defaultExpectation.paramPtrs

		mm_got := NoteServiceMockUpdateParams{ctx, info}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdate.t.Errorf("NoteServiceMock.Update got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.info != nil && !minimock.Equal(*mm_want_ptrs.info, mm_got.info) {
				mmUpdate.t.Errorf("NoteServiceMock.Update got unexpected parameter info, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originInfo, *mm_want_ptrs.info, mm_got.info, minimock.Diff(*mm_want_ptrs.info, mm_got.info))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("NoteServiceMock.Update got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the NoteServiceMock.Update")
		}
		return (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, info)
	}
	mmUpdate.t.Fatalf("Unexpected call to NoteServiceMock.Update. %v %v", ctx, info)
	return
}

// UpdateAfterCounter returns a count of finished NoteServiceMock.Update invocations
func (mmUpdate *NoteServiceMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of NoteServiceMock.Update invocations
func (mmUpdate *NoteServiceMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to NoteServiceMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mNoteServiceMockUpdate) Calls() []*NoteServiceMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*NoteServiceMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *NoteServiceMock) MinimockUpdateDone() bool {
	if m.UpdateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateMock.invocationsDone()
}

// MinimockUpdateInspect logs each unmet expectation
func (m *NoteServiceMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NoteServiceMock.Update at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateCounter := mm_atomic.LoadUint64(&m.afterUpdateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && afterUpdateCounter < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to NoteServiceMock.Update at\n%s", m.UpdateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to NoteServiceMock.Update at\n%s with params: %#v", m.UpdateMock.defaultExpectation.expectationOrigins.origin, *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && afterUpdateCounter < 1 {
		m.t.Errorf("Expected call to NoteServiceMock.Update at\n%s", m.funcUpdateOrigin)
	}

	if !m.UpdateMock.invocationsDone() && afterUpdateCounter > 0 {
		m.t.Errorf("Expected %d calls to NoteServiceMock.Update at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateMock.expectedInvocations), m.UpdateMock.expectedInvocationsOrigin, afterUpdateCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *NoteServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockDeleteInspect()

			m.MinimockGetInspect()

			m.MinimockListInspect()

			m.MinimockUpdateInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *NoteServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *NoteServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockGetDone() &&
		m.MinimockListDone() &&
		m.MinimockUpdateDone()
}
